---
title: 03_Redis事务
category:
  - Redis
date: 2023-02-28
---

<!-- more -->



## 1、事务介绍

- Redis通过**MULTI**、**EXEC**、**WATCH**等命令来实现事务（transaction）功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。

- Redis事务没有隔离级别的概念！所有的命令在事务中并没有被立即执行，只有发起执行命令的时候才会执行！Exec

- Redis单条命令保存原子性，而事务不保证原子性！

***

## 2、事务的实现

一个事务从开始到结束通常会经历以下三个阶段：

1）事务开始。

2）命令入队。

3）事务执行。

### 2.1  事务开始

MULTI命令的执行标志着事务的开始：

![image-20210519000323750](https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084604.png)

MULTI命令可以将执行该命令的客户端从非事务状态切换至事务状态，这一切换是通过在客户端状态的flags属性中打开REDIS_MULTI标识来完成的，MULTI命令的实现可以用以下伪代码来表示：

![image-20210519000341863](https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084605.png)

### 2.2 命令入队

当一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行：

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084606.png" alt="image-20210519000419754" style="zoom: 80%;" />

与此不同的是，当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：

- 如果客户端发送的命令为EXEC、DISCARD、WATCH、MULTI四个命令的其中一个，那么服务器立即执行这个命令。

- 与此相反，如果客户端发送的命令是EXEC、DISCARD、WATCH、MULTI四个命令以外的其他命令，那么服务器并不立即执行这个命令，而是将这个命令放入一个事务队列里面，然后向客户端返回QUEUED回复。

**服务器判断命令是该入队还是该立即执行的过程可以用如下流程图来描述。**

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084607.png" alt="image-20210519000618826" style="zoom:67%;" />

### 2.3 事务队列

每个Redis客户端都有自己的事务状态，这个事务状态保存在客户端状态的mstate属性里面：

![image-20210519000745329](https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084608.png)

事务状态包含一个事务队列，以及一个已入队命令的计数器（也可以说是事务队列的长度）：

![image-20210519000801475](https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084609.png)

事务队列是一个multiCmd类型的数组，数组中的每个multiCmd结构都保存了一个已入队命令的相关信息，包括指向命令实现函数的指针、命令的参数，以及参数的数量：

![image-20210519000821241](https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084610.png)

事务队列以先进先出（FIFO）的方式保存入队的命令，较先入队的命令会被放到数组的前面，而较后入队的命令则会被放到数组的后面。

**举个例子，如果客户端执行以下命令：**

![image-20210519000848848](https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084611.png)

那么服务器将为客户端创建图19-2所示的事务状态：

- 最先入队的SET命令被放在了事务队列的索引0位置上。

- 第二入队的GET命令被放在了事务队列的索引1位置上。

- 第三入队的另一个SET命令被放在了事务队列的索引2位置上。

- 最后入队的另一个GET命令被放在了事务队列的索引3位置上。

![image-20210519001001352](https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084612.png)

### 2.4 执行事务

当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。

举个例子，对于上图所示的事务队列来说，服务器首先会执行命令：

![image-20210519001120968](https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084613.png)

接着执行命令：

![image-20210519001143158](https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084614.png)

之后执行命令：

![image-20210519001157886](https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084615.png)

再之后执行命令：

![image-20210519001214188](https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084616.png)

最后，服务器会将执行这四个命令所得的回复返回给客户端：

![image-20210519001228155](https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084617.png)

**EXEC命令的实现原理可以用以下伪代码来描述：**

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084618.png" alt="image-20210519001301190" style="zoom:67%;" />



***

## 3、WATCH命令的实现

WATCH命令是一个乐观锁（optimistic locking）,他可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。

以下是一个事务执行失败的例子：

```
redis> WATCH "name"
OK
redis> MULTI
OK
redis> SET "name" "peter"
QUEUED
redis> EXEC
(nil)
```

下表展示了上面的例子是如何失败的。

| 时间 | 客户端A            | 客户端B          |
| ---- | ------------------ | ---------------- |
| T1   | WATCH "name"       |                  |
| T2   | MULTI              |                  |
| T3   | SET "name" "peter" |                  |
| T4   |                    | SET "name" "bob" |
| T5   | EXEC               |                  |

在时间T4，客户端B修改了“name”键的值，当客户端A在T5执行EXEC命令时，服务器会发现WATCH监视的键“name”已经被修改，因此服务器拒绝执行客户端A的事务，并向客户端A返回**空回复**。

### 3.1 使用WATCH命令监视数据库键

每个Redis数据库都保存着一个watched_keys字典，这个字典的键是某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端：

![image-20210519232328986](https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084619.png)

**通过watched_keys字典，服务器可以清楚地知道哪些数据库键正在被监视，以及哪些客户端正在监视这些数据库键。**

下图3-1是一个watched_keys字典的示例，从这个watched_keys字典中可以看出：

- 客户端c1和c2正在监视键"name"。

- 客户端c3正在监视键"age"。

- 客户端c2和c4正在监视键"address"。

![image-20210519232536719](https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084620.png)

<div align="center">图3-1</div>

通过执行WATCH命令，客户端可以在watched_keys字典中与被监视的键进行关联。举个例子，如果当前客户端为c10086，那么客户端执行以下WATCH命令之后：

![image-20210519232747270](https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084621.png)

图3-1展示的watched_keys字典将被更新至图3-2所示的状态，其中用虚线包围的两个c10086节点就是由刚刚执行的WATCH命令添加到字典中的。

![image-20210519232829029](https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084622.png)

<div align="center">图3-2</div>



### 3.2 监视机制的触发

所有对数据库进行修改的命令，比如SET、LPUSH、SADD、ZREM、DEL、FLUSHDB等等，在执行之后都会调用multi.c/touchWatchKey函数对watched_keys字典进行检查，**查看是否有客户端正在监视刚刚被命令修改过的数据库键**，如果有的话，那么touchWatchKey函数会将监视被修改键的客户端的**REDIS_DIRTY_CAS**标识打开，表示该客户端的事务安全性已经被破坏。

举个例子，对于图3-3所示的watched_keys字典来说：

- 如果键"name"被修改，那么c1、c2、c10086三个客户端的REDIS_DIRTY_CAS标识将被打开。

- 如果键"age"被修改，那么c3和c10086两个客户端的REDIS_DIRTY_CAS标识将被打开。

- 如果键"address"被修改，那么c2和c4两个客户端的REDIS_DIRTY_CAS标识将被打开。

![image-20210519233648814](https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084623.png)

<div align="center">图3-3</div>

### 3.3 判断事务是否安全

当服务器接收到一个客户端发来的EXEC命令时，服务器会根据这个客户端是否打开了REDIS_DIRTY_CAS标识来决定是否执行事务：

- 如果客户端的REDIS_DIRTY_CAS标识已经被打开，那么说明客户端所监视的键当中，至少有一个键已经被修改过了，在这种情况下，客户端提交的事务已经不再安全，所以服务器会拒绝执行客户端提交的事务。

- 如果客户端的REDIS_DIRTY_CAS标识没有被打开，那么说明客户端监视的所有键都没有被修改过（或者客户端没有监视任何键），事务仍然是安全的，服务器将执行客户端提交的这个事务。

这个判断是否执行事务的过程可以用流程图3-4来描述。

![image-20210519233819359](https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084624.png)

<div align="center">图3-4</div>

举个例子，对于图3-3所示的watched_keys字典来说，如果某个客户端对"name"键进行了修改（比如执行SET"name""john"），那么c1、c2、c10086三个客户端的REDIS_DIRTY_CAS标识将被打开。当这三个客户端向服务器发送EXEC命令的时候，服务器会拒绝执行它们提交的事务，以此来保证事务的安全性。

### 3.4  一个完整的WATCH事务执行过程

```
127.0.0.1:6379> watch money # 监视 money
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> DECRBY money 10
QUEUED
127.0.0.1:6379> INCRBY out 10
QUEUED
127.0.0.1:6379> exec # 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失
败！
(nil)
```



***

## 4. 事务执行的过程中几种情况

### 4.1 正常执行事务

```shell
127.0.0.1:6379> multi # 开启事务
OK
# 命令入队
127.0.0.1:6379> set k1 v1
QUEUED
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> get k2
QUEUED
127.0.0.1:6379> set k3 v3
QUEUED
127.0.0.1:6379> exec # 执行事务
1) OK
2) OK
3) "v2"
4) OK
```

### 4.2 放弃事务

```shell
127.0.0.1:6379> multi # 开启事务
OK
127.0.0.1:6379> set k1 v1
QUEUED
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> set k4 v4
QUEUED
127.0.0.1:6379> DISCARD # 取消事务
OK
127.0.0.1:6379> get k4 # 事务队列中命令都不会被执行！
(nil)
```

### 4.3 编译型异常

代码有问题！ 命令有错 ，事务中所有的命令都不会被执行！

```shell
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set k1 v1
QUEUED
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> set k3 v3
QUEUED
127.0.0.1:6379> getset k3 # 错误的命令
(error) ERR wrong number of arguments for 'getset' command
127.0.0.1:6379> set k4 v4
QUEUED
127.0.0.1:6379> set k5 v5
QUEUED
127.0.0.1:6379> exec # 执行事务报错！
(error) EXECABORT Transaction discarded because of previous errors.
127.0.0.1:6379> get k5 # 所有的命令都不会被执行！
(nil)
```

### 4.4 运行时异常

如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常！

```shell
127.0.0.1:6379> set k1 "v1"
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> incr k1 # 会执行的时候失败！
QUEUED
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> set k3 v3
QUEUED
127.0.0.1:6379> get k3
QUEUED
127.0.0.1:6379> exec
1) (error) ERR value is not an integer or out of range # 虽然第一条命令报错了，但是
依旧正常执行成功了！
2) OK
3) OK
4) "v3"
127.0.0.1:6379> get k2
"v2"
127.0.0.1:6379> get k3
"v3"
```



***

## 5、事务的ACID性质

在Redis中，事务具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation）、并且当Redis运行在某种特定的持久化模式下，事务也具有耐久性（Durability）。

### 5.1  原子性

- 事务具有原子性指的是，数据库将事务中的多个操作当作一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行。

- 对于Redis的事务功能来说，事务队列中的命令要么就全部都执行，要么就一个都不执行，**因此，Redis的事务是具有原子性的。**

- Redis的事务和传统的关系型数据库事务的最大区别在于，**Redis不支持事务回滚机制（rollback）**，即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止。
  - 详见 [4.4运行时异常]

**为什么Redis不支持回滚？**

Redis的作者在事务功能的文档中解释说，不支持事务回滚是因为这种复杂的功能和Redis追求简单高效的设计主旨不相符，并且他认为，Redis事务的执行时错误通常都是编程错误产生的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为Redis开发事务回滚功能。

### 5.2  一致性

事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。

“一致”指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。

Redis通过谨慎的错误检测和简单的设计来保证事务的一致性，

#### 5.2.1 入队错误

如果一个事务在入队命令的过程中，出现了命令不存在，或者命令的格式不正确等情况，那么Redis将拒绝执行这个事务。

因为服务器会拒绝执行入队过程中出现错误的事务，所以Redis事务的一致性不会被带有入队错误的事务影响。

#### 5.2.2 执行错误

除了入队时可能发生错误以外，事务还可能在执行的过程中发生错误。

关于这种错误有两个需要说明的地方：

- 执行过程中发生的错误都是一些不能在入队时被服务器发现的错误，这些错误只会在命令实际执行时被触发。

- 即使在事务的执行过程中发生了错误，服务器也不会中断事务的执行，它会继续执行事务中余下的其他命令，并且已执行的命令（包括执行命令所产生的结果）不会被出错的命令影响。

在下面展示的这个例子中，我们首先用SET命令将键"msg"设置成了一个字符串键，然后在事务里面尝试对"msg"键执行只能用于列表键的RPUSH命令，这将引发一个错误，并且这种错误只能在事务执行（也即是命令执行）期间被发现：

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084625.png" alt="image-20210520000846818" style="zoom:67%;" />

因为在事务执行的过程中，出错的命令会被服务器识别出来，并进行相应的错误处理，所以这些出错命令不会对数据库做任何修改，也不会对事务的一致性产生任何影响。

#### 5.2.3 服务器停机

如果Redis服务器在执行事务的过程中停机，那么根据服务器所使用的持久化模式，可能有以下情况出现：

- 如果服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据总是一致的。

- 如果服务器运行在RDB模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的RDB文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的RDB文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。

- 如果服务器运行在AOF模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的AOF文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的AOF文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。

综上所述，无论Redis服务器运行在哪种持久化模式下，事务执行中途发生的停机都不会影响数据库的一致性。

#### 5.2.4  隔离性

事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。

因为Redis使用单线程的方式来执行事务（以及事务队列中的命令），并且服务器保证，在执行事务期间不会对事务进行中断，**因此，Redis的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。**

#### 5.2.5  耐久性

- 当服务器在无持久化的内存模式下运作时，事务不具有耐久性：一旦服务器停机，包括事务数据在内的所有服务器数据都将丢失。

- 当服务器在RDB持久化模式下运作时，服务器只会在特定的保存条件被满足时，才会执行BGSAVE命令，对数据库进行保存操作，并且异步执行的BGSAVE不能保证事务数据被第一时间保存到硬盘里面，**因此RDB持久化模式下的事务也不具有耐久性。**

- 当服务器运行在**AOF持久化**模式下，并且**appendfsync选项的值为always**时，程序总会在执行命令之后调用同步（sync）函数，将命令数据真正地保存到硬盘里面，因此**这种配置下的事务是具有耐久性的。**

- 当服务器运行在**AOF持久化**模式下，并且**appendfsync选项的值为everysec**时，程序会每秒同步一次命令数据到硬盘。因为停机可能会恰好发生在等待同步的那一秒钟之内，这可能会造成事务数据丢失，所以**这种配置下的事务不具有耐久性**。

- 当服务器运行在**AOF持久化模式**下，并且**appendfsync选项的值为no**时，程序会交由操作系统来决定何时将命令数据同步到硬盘。因为事务数据可能在等待同步的过程中丢失，所以**这种配置下的事务不具有耐久性。**

  

  `no-appendfsync-on-rewrite`配置选项标识在对aof文件压缩时，是否执行同步操作。对耐久性有影响

> **不论Redis在什么模式下运作，在一个事务的最后加上SAVE命令总可以保证事务的耐久性：**

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/Redis/20220716084626.png" alt="image-20210520001541751" style="zoom:67%;" />

​			**不过因为这种做法的效率太低，所以并不具有实用性。**



***

## 6、重点回顾

- 事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。

- 多个命令会被入队到事务队列中，然后按先进先出（FIFO）的顺序执行。

- 事务在执行过程中不会被中断，当事务队列中的所有命令都被执行完毕之后，事务才会结束。

- 带有WATCH命令的事务会将客户端和被监视的键在数据库的watched_keys字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的REDIS_DIRTY_CAS标志打开。

- 只有在客户端的REDIS_DIRTY_CAS标志未被打开时，服务器才会执行客户端提交的事务，否则的话，服务器将拒绝执行客户端提交的事务。

- Redis的事务总是具有ACID中的原子性、一致性和隔离性，当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。

