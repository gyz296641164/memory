---
title: 13 从磁盘读取数据页到Buffer Pool的时候，free链表有什么用？
category:
  - MySQL
date: 2023-02-27
---

<!-- more -->


## 1、数据库启动的时候，是如何初始化Buffer Pool的？

其实这个也很简单，数据库只要一启动，就会按照你设置的Buffer Pool大小，稍微再加大一点，去找操作系统申请一块内存区域，作为Buffer Pool的内存区域。

然后当内存区域申请完毕之后，数据库就会按照默认的缓存页的16KB的大小以及对应的800个字节左右的描述数据的大小，在Buffer Pool中划分出来一个一个的缓存页和一个一个的他们对应的描述数据。

然后当数据库把Buffer Pool划分完毕之后，看起来就是之前我们看到的那张图了，如下图所示。

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/mysql/01-33/202210201125721.png" alt="image-20211004152419762"/>

只不过这个时候，Buffer Pool中的一个一个的缓存页都是空的，里面什么都没有，要等数据库运行起来之后，当我们要对数据执行增删改查的操作的时候，才会把数据对应的页从磁盘文件里读取出来，放入Buffer Pool中的缓存页中。



***

## 2、我们怎么知道哪些缓存页是空闲的呢？

当你的数据库运行起来之后，你肯定会不停的执行增删改查的操作，此时就需要不停的从磁盘上读取一个一个的数据页放入Buffer Pool中的对应的缓存页里去，把数据缓存起来，那么以后就可以对这个数据在内存里执行增删改查了。

但是此时在从磁盘上读取数据页放入Buffer Pool中的缓存页的时候，必然涉及到一个问题，那就是**哪些缓存页是空闲的？**

因为默认情况下磁盘上的数据页和缓存页是一 一对应起来的，都是16KB，一个数据页对应一个缓存页。所以我们必须要知道`Buffer Pool`中哪些缓存页是空闲的状态。

所以数据库会为Buffer Pool设计一个**free链表**，他是一个**双向链表数据结构**，这个free链表里，每个节点就是一个空闲的缓存页的描述数据块的地址，也就是说，只要你一个缓存页是空闲的，那么他的描述数据块就会被放入这个free链表中。

刚开始数据库启动的时候，可能所有的缓存页都是空闲的，因为此时可能是一个空的数据库，一条数据都没有，所以此时所有缓存页的描述数据块，都会被放入这个free链表中。

我们看下图所示。

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/mysql/01-33/202210201125722.png" alt="image-20211004152820694"/>

大家可以看到上面出现了一个free链表，这个free链表里面就是各个缓存页的描述数据块，**只要缓存页是空闲的**，那么他们对应的描述数据块就会加入到这个free链表中，每个节点都会双向链接自己的前后节点，组成一个双向链表。

除此之外，这个free链表有一个**基础节点**，他会引用链表的头节点和尾节点，里面还存储了`链表中有多少个描述数据块的节点`，也就是有多少个空闲的缓存页。



***

## 3、free链表占用多少内存空间？

可能有的人会以为这个描述数据块，在Buffer Pool里有一份，在free链表里也有一份，好像在内存里有两个一模一样的描述数据块，其实这么想就大错特错了。

**这个free链表，他本身其实就是由Buffer Pool里的描述数据块组成的**，你可以认为是每个描述数据块里都有两个指针，一个是free_pre，一个是free_next，分别指向自己的上一个free链表的节点，以及下一个free链表的节点。

通过Buffer Pool中的描述数据块的free_pre和free_next两个指针，就可以把所有的描述数据块串成一个free链表，上面为了画图需要，所以把描述数据块单独画了一份出来，表示他们之间的指针引用关系。

对于free链表而言，只有一个**基础节点**是不属于Buffer Pool的，他是40字节大小的一个节点，里面就存放了`free链表的头节点的地址`，`尾节点的地址`，还有free链表里当前有多少个`节点`。



***

## 4、如何将磁盘上的页读取到Buffer Pool的缓存页中去?

**当你需要把磁盘上的数据页读取到Buffer Pool中的缓存页里去的时候，是怎么做到的？**

首先，我们需要从free链表里获取一个描述数据块，然后就可以对应的获取到这个描述数据块对应的空闲缓存页，我们看下图所示。

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/mysql/01-33/202210201125723.png" alt="image-20211004155651727"/>

接着我们就可以把磁盘上的数据页读取到对应的缓存页里去，同时把相关的一些描述数据写入缓存页的描述数据块里去，比如这个数据页所属的表空间之类的信息，最后把那个描述数据块从free链表里去除就可以了，如下图所示。

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/mysql/01-33/202210201125724.png" alt="image-20211004160817645"/>

**这个描述数据块是怎么从free链表里移除的呢？**

代码演示:

假设有一个描述数据块02，他的上一个节点是描述数据块01，下一个节点是描述数据块03，那么他在内存中的数据结构如下。

```
//描述数据块
DescriptionDataBlock{
	//这个块自己就是block2
	block_id = block2;
	//在free链表中的上一个节点是block1
	free_pre = block1;
	//在free链表中的下一个节点是block3
	free_next = block3;
}
```

现在假设block03被使用了，要从free链表中移除，那么此时直接就可以把block02节点的free_next设置为null就可以了，block03就从free链表里失去引用关系了，如下所示。

```
//描述数据块
DescriptionDataBlock{
	//这个块自己就是block2
	block_id = block2;
	//在free链表中的上一个节点是block1
	free_pre = block1;
	//在free链表中的下一个节点是空的
	free_next = null;
}
```

想必看到这里，大家就完全明白，磁盘中的数据页是如何读取到Buffer Pool中的缓存页里去的了，而且这个过程中free链表是用来干什么的。

***

## 5、你怎么知道数据页有没有被缓存？

**你怎么知道一个数据页有没有被缓存呢？**

我们在执行增删改查的时候，肯定是先看看这个数据页有没有被缓存，如果没被缓存就走上面的逻辑，从free链表中找到一个空闲的缓存页，从磁盘上读取数据页写入缓存页，写入描述数据，从free链表中移除这个描述数据块。

但是如果数据页已经被缓存了，那么就会直接使用了。

所以其实**数据库还会有一个哈希表数据结构，他会用表空间号+数据页号，作为一个key，然后缓存页的地址作为value。**

当你要使用一个数据页的时候，通过**表空间号+数据页号**作为key去这个哈希表里查一下，如果没有就读取数据页，如果已经有了，就说明数据页已经被缓存了。

我们看下图，又引入了一个数据页缓存哈希表的结构。也就是说，每次你读取一个数据页到缓存之后，都会在这个哈希表中写入一个key-value对，key就是表空间号+数据页号，value就是缓存页的地址，那么下次如果你再使用这个数据页，就可以从哈希表里直接读取出来他已经被放入一个缓存页了。

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/mysql/01-33/202210201125725.png" alt="image-20211004161433486"/>



***

## 6、今日思考题

**在MySQL内部操作的时候，是表空间+数据页的概念。那么大家觉得这两者之间的区别是什么？他们之间的联系是什么？**

其实简单来讲，**一个是逻辑概念，一个是物理概念。**表、列和行，都是逻辑概念，我们只知道数据库里有一个表，表里有几个字段，有多少行，但是这些表里的数据，在数据库的磁盘上如何存储的，你知道吗？我们是不关注的，所以他们都是逻辑上的概念。

表空间、数据页，这些东西，都是物理上的概念，实际上在物理层面，你的表里的数据都放在一个表空间中，表空间是由一堆磁盘上的数据文件组成的，这些数据文件里都存放了你表里的数据，这些数据是由一个一个的数据页组织起来的，这些都是物理层面的概念，这就是他们之间的区别。

