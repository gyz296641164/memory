---
title: 03 用一次数据更新流程，初步了解InnoDB存储引擎的架构设计
category:
  - MySQL
date: 2023-02-27
---

<!-- more -->


## 1、更新语句在MySQL中是如何执行的？  

我们已经知道MySQL最常用的就是`InnoDB存储引擎`，那么我们今天借助一条更新语句的执行，来初步的了解一下InnoDB存储引擎的架构设计。 

首先假设我们有一条SQL语句是这样的：

```
update users set name='xxx' where id=10   
```

那么我们先想一下这条SQL语句是如何执行的？

首先肯定是我们的系统通过一个数据库连接发送到了MySQL上，然后肯定会经过`SQL接口`、`解析器`、`优化器`、`执行器`几个环节，解析SQL语句，生成执行计划，接着去由执行器负责这个计划的执行，调用InnoDB存储引擎的接口去执行。  

所以先看下图，大致还是会走下图的这个流程  

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/mysql/01-33/202210201123602.png" alt="image-20210918231615674"/>

我们来探索一下这个存储引擎里的架构设计，以及如何基于存储引擎完成一条更新语句的执行  。



***

## 2、InnoDB的重要内存结构：缓冲池  

InnoDB存储引擎中有一个非常重要的放在内存里的组件，就是**缓冲池（Buffer Pool）**，这里面会缓存很多的数据，以便于以后在查询的时候，万一你要是内存缓冲池里有数据，就可以不用去查磁盘了，我们看下图。  

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/mysql/01-33/202210201123603.png" alt="image-20210918232134966"/>

引擎要执行更新语句的时候 ，比如对“id=10”这一行数据，他其实会先将“id=10”这一行数据看看是否在缓冲池里，如果不在的话，那么会直接从磁盘里加载到缓冲池里来，而且接着还会对这行记录加**独占锁**。

因为我们想一下，在我们更新“id=10”这一行数据的时候，肯定是不允许别人同时更新的，所以必须要对这行记录加独占锁。

至于锁的详细分析，后续也会说道，在这里先初步了解即可，我们看下面的图    

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/mysql/01-33/202210201123604.png" alt="image-20210918232320378"/>



***

## 3、undo日志文件：如何让你更新的数据可以回滚？  

接着下一步，假设“id=10”这行数据的name原来是“zhangsan”，现在我们要更新为“xxx”，那么此时我们得先把要更新的原来的值“zhang  san”和“id=10”这些信息，写入到**undo日志**文件中去。  

如果我们执行一个更新语句，要是他是在一个事务里的话，那么事务提交之前我们都是可以对数据进行回滚的，也就是把你更新为“xxx”的值回滚到之前的“zhangsan”去。  

所以为了考虑到未来可能要**回滚数据**的需要，这里会把你更新前的值写入undo日志文件，我们看下图。  

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/mysql/01-33/202210201123605.png" alt="image-20210918232537139"/>



***

## 4、更新buffer pool中的缓存数据  

当我们把要更新的那行记录从磁盘文件加载到缓冲池，同时对他加锁之后，而且还把更新前的旧值写入undo日志文件之后，我们就可以正式开始更新这行记录了，更新的时候，先是会更新缓冲池中的记录，此时这个数据就是**脏数据**了。

这里所谓的更新内存缓冲池里的数据，意思就是把内存里的“id=10”这行数据的name字段修改为“xxx”。那么为什么说此时这行数据就是脏数据了呢？  

因为这个时候磁盘上“id=10”这行数据的name字段还是“zhangsan”，但是内存里这行数据已经被修改了，所以就会叫他是脏数据。

我们看下图，我同时把几个步骤的序号标记出来了。  

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/mysql/01-33/202210201123606.png" alt="image-20210918232901706"/>



***

## 5、Redo Log Buffer：万一系统宕机，如何避免数据丢失？  

接着我们来思考一个问题，按照上图的说明，现在已经把内存里的数据进行了修改，但是磁盘上的数据还没修改。

那么此时万一MySQL所在的机器宕机了，必然会导致内存里修改过的数据丢失，这可怎么办呢？  

这个时候，就必须要把对内存所做的修改写入到一个**Redo Log Buffer**里去，这也是内存里的一个缓冲区，是用来存放redo日志的  。

所谓的**redo日志**，就是记录下来你对数据做了什么修改，比如对“id=10这行记录修改了name字段的值为xxx”，这就是一个日志。  

看下图的示意 ：

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/mysql/01-33/202210201123607.png" alt="image-20210918233907815"/>

这个**redo日志**其实是用来在MySQL突然宕机的时候，用来**恢复你更新过的数据**的，但是我们现在还没法直接讲解redo是如何使用的，毕竟现在redo日志还仅仅停留在内存缓冲里 。



***

## 6、如果还没提交事务，MySQL宕机了怎么办？  

在数据库中，哪怕执行一条SQL语句，其实也可以是一个独立的事务，只有当你提交事务之后，SQL语句才算执行结束。 

所以这里我们都知道，到目前为止，其实还没有提交事务，那么此时如果MySQL崩溃，必然导致内存里Buffer Pool中的修改过的数据都丢失，同时你写入Redo Log Buffer中的redo日志也会丢失。

我们看下图   

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/mysql/01-33/202210201123608.png" alt="image-20210918234324906"/>

那么此时数据丢失要紧吗？

- 其实是不要紧的，因为你一条更新语句，没提交事务，就代表他没执行成功，此时MySQL宕机虽然导致内存里的数据都丢失了，但是你会发现，磁盘上的数据依然还停留在原样子。
- 也就是说，“id=1”的那行数据的name字段的值还是老的值，“zhangsan”，所以此时你的这个事务就是执行失败了，没能成功完成更新，你会收到一个数据库的异常。然后当mysql重启之后，你会发现你的数据并没有任何变化。
- 所以此时如果mysql宕机，不会有任何的问题。  

***

## 7、提交事务的时候将redo日志写入磁盘中  

接着我们想要提交一个事务了，此时就会根据一定的策略把redo日志从**redo log buffer**里刷入到磁盘文件里去。  

此时这个策略是通过`innodb_flush_log_at_trx_commit`来配置的，他有几个选项。

当这个**参数的值为0**的时候，那么你提交事务的时候，不会把`redo log buffer`里的数据刷入磁盘文件的，此时可能你都提交事务了，结果mysql宕机了，然后此时内存里的数据全部丢失。  

相当于你提交事务成功了，但是由于MySQL突然宕机，导致内存中的数据和redo日志都丢失了，我们看下图：  

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/mysql/01-33/202210201123609.png" alt="image-20210918235145054"/>

当这个**参数的值为1**的时候，你提交事务的时候，就必须把redo log从内存刷入到磁盘文件里去，只要事务提交成功，那么redo log就
必然在磁盘里了，我们看下图：  

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/mysql/01-33/202210201123610.png" alt="image-20210918235250603"/>

那么只要提交事务成功之后，redo日志一定在磁盘文件里，此时你肯定会有一条redo日志说了，“我此时对哪个数据做了一个什么修改，比如name字段修改为xxx了”。

然后哪怕此时buffer pool中更新过的数据还没刷新到磁盘里去，此时内存里的数据是已经更新过的“name=xxx”，然后磁盘上的数据还是没更新过的“name=zhangsan”。  

我们看下图，提交事务之后，可能处于的一个状态。  

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/mysql/01-33/202210201123611.png" alt="image-20210918235400120"/>

此时如果说提交事务后处于上图的状态，然后mysql系统突然崩溃了，此时会如何？会丢失数据吗？

肯定不会啊，因为虽然内存里的修改成name=xxx的数据会丢失，但是redo日志里已经说了，对某某数据做了修改name=xxx。  

所以此时mysql重启之后，他可以根据redo日志去恢复之前做过的修改，我们看下图  .

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/mysql/01-33/202210201123612.png" alt="image-20210918235539776"/>

最后来看看，如果`innodb_flush_log_at_trx_commit`参数的**值是2**呢？  

他的意思就是，提交事务的时候，把redo日志写入磁盘文件对应的os cache缓存里去，而不是直接进入磁盘文件，可能1秒后才会把os cache里的数据写入到磁盘文件里去。

这种模式下，你提交事务之后，redo log可能仅仅停留在os cache内存缓存里，没实际进入磁盘文件，万一此时你要是机器宕机了，那么os cache里的redo log就会丢失，同样会让你感觉提交事务了，结果数据丢了，看下图。  

<img src="https://studyimages.oss-cn-beijing.aliyuncs.com/img/mysql/01-33/202210201123613.png" alt="image-20210918235718813"/>



***

## 8、小思考题：三种redo日志刷盘策略到底选择哪一种？  

大家觉得在提交事务的时候，我们对redo日志的刷盘策略应该选择哪一种？每一种刷盘策略的优缺点分别是什么？为什么？  
