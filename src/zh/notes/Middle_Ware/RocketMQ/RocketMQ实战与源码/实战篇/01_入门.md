---
title: 01_入门
category:
  - RocketMQ
date: 2025-10-24
---


## 什么是消息中间件？

**消息中间件(MessageQueue，MQ)**

![image-20240604224504209](https://studyimages.oss-cn-beijing.aliyuncs.com/img/RocketMQ/202406/d21b7b5752e4c5ce.png)

消息中间件，英文Message Queue，简称MQ。它没有标准定义，一般认为：消息中间件属于分布式系统中一个子系统，关注于数据的发送和接收，利用高效可靠的异步消息传递机制对分布式系统中的其余各个子系统进行集成。

1. **解耦**：应用程序之间通过消息进行通信，而不是直接调用，这降低了它们之间的依赖性。
2. **异步通信**：发送者发送消息后可以继续执行其他任务，而不必等待接收者处理消息。
3. **缓冲**：消息中间件可以暂时存储消息，直到接收者准备好处理它们。
4. **持久化**：消息可以被存储在持久化存储中，以确保在发送者和接收者之间的通信中断时不会丢失消息。
5. **消息过滤和路由**：消息中间件可以根据特定的规则将消息路由到不同的接收者。
6. **事务性**：支持事务性消息传递，确保消息的发送和接收是原子性的。
7. **负载均衡**：消息中间件可以在多个接收者之间分配消息负载，提高系统的处理能力。
8. **可靠性**：提供消息确认机制，确保消息被正确处理。
9. **安全性**：支持消息加密和认证，保护消息不被未授权访问。

**一句话总结：消息中间件不生产消息，只是消息的搬运工**。

常见的消息中间件包括：

- **ActiveMQ**：一个流行的开源消息代理，支持多种消息协议。
- **RabbitMQ**：一个高性能的消息代理，支持多种编程语言。
- **RocketMQ**：一个高性能、高可靠、高实时、分布式的消息中间件。
- **Kafka**：一个分布式流处理平台，用于构建实时数据管道和流应用程序。
- **IBM MQ**：IBM提供的一个企业级消息中间件。
- **Amazon SQS**：亚马逊提供的托管消息队列服务。

---

## 消息中间件的使用场景

### 异步与解耦

系统的耦合性越高，容错性就越低。以电商应用为例，用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障或者因为升级等原因暂时不可用，都会造成下单操作异常，影响用户使用体验。

使用消息中间件，系统的耦合性就会提高了。比如物流系统发生故障，需要几分钟才能来修复，在这段时间内，物流系统要处理的数据被缓存到消息队列中，用户的下单操作正常完成。当物流系统恢复后，继续处理存放在消息队列中的订单消息即可，终端系统感知不到物流系统发生过几分钟故障。

![image-20240604225040424](https://studyimages.oss-cn-beijing.aliyuncs.com/img/RocketMQ/202406/48352619a62064b9.png)

### 流量削峰

应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮。有了消息队列可以将大量请求缓存起来，分散到很长一段时间处理，这样可以大大提到系统的稳定性和用户体验。

互联网公司的大促场景（双十一、店庆活动、秒杀活动）都会使用到MQ。

![image-20240604225102531](https://studyimages.oss-cn-beijing.aliyuncs.com/img/RocketMQ/202406/133c6e0dd1a7be54.png)

### 数据分发

通过消息队列可以让数据在多个系统更加之间进行流通。数据的产生方不需要关心谁来使用数据，只需要将数据发送到消息队列，数据使用方直接在消息队列中直接获取数据即可。

接口调用的弊端，无论是新增系统，还是移除系统，代码改造工作量都很大。

![image-20240604225849989](https://studyimages.oss-cn-beijing.aliyuncs.com/img/RocketMQ/202406/053d9bfad62e08d1.png)

使用MQ做数据分发好处，无论是新增系统，还是移除系统，代码改造工作量较小。所以使用MQ做数据的分发，可以提高团队开发的效率。

---

## RocketMQ的产品发展

> 官网：http://rocketmq.apache.org/dowloading/releases/
>
> Github：https://github.com/apache/rocketmq/

### 前世

MetaQ：2011年，阿里基于Kafka的设计使用Java完全重写并推出了MetaQ 1.0版本 。

2012年，阿里对MetaQ的存储进行了改进，推出MetaQ 2.0，同年阿里把Meta2.0从阿里内部开源出来，取名RocketMQ，为了命名上的规范以及版本上的延续，对外称为RocketMQ3.0。

### 今生

2016年，阿里宣布将开源分布式消息中间件RocketMQ捐赠给Apache，同时RocketMQ3也升级为RocketMQ4，现在RocketMQ主要维护的是4.x的版本，也是大家使用得最多的版本。

### 未来

2021年，伴随众多企业全面上云以及云原生的兴起，RocketMQ也在github上发布5.0版本。RocketMQ5的改动非常大，同时也明确了版本定位，RocketMQ 5.0定义为云原生的消息、事件、流的超融合平台。

---

## RocketMQ各部分角色介绍

![image-20240604232028752](https://studyimages.oss-cn-beijing.aliyuncs.com/img/RocketMQ/202406/f8af463f9a45dd3b.png)

### NameServer

NameServer是整个RocketMQ的“大脑”，它是RocketMQ的`服务注册中心`，所以RocketMQ需要先启动NameServer再启动Rocket中的Broker。

Broker在启动时向所有NameServer注册（主要是服务器地址等），生产者在发送消息之前先从NameServer获取Broker服务器地址列表（消费者一样），然后根据负载均衡算法从列表中选择一台服务器进行消息发送。

### 主机(Broker)

RocketMQ的核心，用于暂存和传输消息。

### 生产者(Producer)

生产者：也称为消息发布者，负责生产并发送消息至RocketMQ。

### 消费者(Consumer)

消费者：也称为消息订阅者，负责从RocketMQ接收并消费消息。

### 消息(Message)

消息：生产或消费的数据，对于RocketMQ来说，消息就是字节数组。

---

## 使用RocketMQ的核心概念

![image-20240604232936333](https://studyimages.oss-cn-beijing.aliyuncs.com/img/RocketMQ/202406/f157e3bd99f5bbc7.png)

### 主题(Topic)

标识RocketMQ中一类消息的逻辑名字，消息的逻辑管理单位。无论消息生产还是消费，都需要指定Topic。主题主要用于区分消息的种类：一个生产者可以发送消息给一个或者多个Topic，消息的消费者也可以订阅一个或者多个Topic消息。

### 消息队列(Message Queue)

简称Queue或Q。消息物理管理单位。一个Topic将有若干个Q。

无论生产者还是消费者，实际的生产和消费都是针对Q级别。例如Producer发送消息的时候，会预先选择（默认轮询）好该Topic下面的某一条Q发送；Consumer消费的时候也会负载均衡地分配若干个Q，只拉取对应Q的消息。

若一个Topic创建在不同的Broker，则不同的broker上都有若干Q，消息将物理地存储落在不同Broker结点上，具有水平扩展的能力。

### 分组(Group)

**生产者**：标识发送同一类消息的Producer，通常发送逻辑一致。发送普通消息的时候，仅标识使用，并无特别用处。**主要作用于事务消息**；

**消费者**：标识一类Consumer的集合名称，这类Consumer通常消费一类消息（也称为Consumer Group），且消费逻辑一致。同一个Consumer Group下的各个实例将共同消费topic的消息，起到负载均衡的作用。

### 标签(Tag)

RocketMQ支持给在发送的时候给消息打tag，同一个topic的消息虽然逻辑管理是一样的。但是消费同一个topic时，如果你消费订阅的时候指定的是tagA，那么tagB的消息将不会投递。

### 偏移量(Offset)

RocketMQ中，有很多offset的概念。一般我们只关心暴露到客户端的offset。不指定的话，就是指Message Queue下面的offset。

Message queue是无限长的数组。一条消息进来下标就会涨1,而这个数组的下标就是offset，Message queue中的max offset表示消息的最大offset。

Consumer offset可以理解为标记Consumer Group在一条逻辑Message Queue上，消息消费到哪里即消费进度。但从源码上看，这个数值是消费过的最新消费的消息offset+1，即实际上表示的是**下次拉取的offset位置**。
